<html>
<head>
    <link rel="stylesheet" href="styles/style.css" />
</head>
<body>

    <div class="page">
        <div class="directory">
            <div class="logo"><img src="images/tictactoe.png" /></div>
        </div>
        <div class="main"><a class="newGame" href="#/new">New Game</a></div>
    </div>

<script type="text/template" id="ttt-board-template">

<table id="play-table" class="ttt-board <%= done %>">
    <tr>
        <% var j = 0; %>
        <% _.each(pieces, function(piece){ %>
            <% if(j == 3 || j == 6){ %>
                </tr><tr>
            <% } %>
            <% j++ %>
            <td><%= piece %></td>
        <% }); %>
    </tr>
</table>

</script>



<script src="scripts/jquery.min.js"></script>
<script src="scripts/underscore-min.js"></script>
<script src="scripts/backbone.js"></script>
<script>
    var tttGameBoard = Backbone.View.extend({
        el: ".main",
        render: function(pieces) {
            //render board
            var done = (pieces["complete"] != undefined && pieces["complete"] == true)?"complete":"";
            if(done)
                delete pieces["complete"];
            var boardTemplate = _.template($('#ttt-board-template').html(), {"pieces": pieces, "done": done});
            this.$el.html(boardTemplate);
        }
    });

    var tttGameState = Backbone.Model.extend({
        defaults: function(){
            return {
                turn: "X"
            };
        },
        nextTurn: function(){
            //switch to opposite state on call
            if (this.get('turn') == "X")
                this.set("turn", "O");
            else
                this.set("turn", "X");
        },
        evalGame: function(positions, winningCombos, lastPlay){
            //return boolean false if not over, else return winner character (eg. "X");
            
            var currentPlayer = lastPlay.player;

            //don't run if min moves to win hasn't been reached
            if(positions[currentPlayer].length < 3) return false;

            var possibleValues = [],
                win = false,
                inc = 0,
                winningValues = [];

            _.each(winningCombos, function(combo){
                if(combo.indexOf(parseInt(lastPlay.tile)) != -1){
                    possibleValues.push(combo);
                }
            });

            _.each(possibleValues, function(combo){
                _.each(combo, function(num){
                    if(positions[currentPlayer].indexOf(num.toString()) != -1)
                        inc++;
                });

                if(inc === 3) //winner - add to winning list
                    winningValues = winningValues.concat(_.difference(combo, winningValues));

                inc = 0;
            });

            if(winningValues.length !== 0)
                return {"winner": currentPlayer, "sequence": winningValues.join('-')};

            return false;
        }

    });

    var tttGamePiece = Backbone.Model.extend({
        defaults: function(){
            return {
                inPlay: {},
                positions: {"X": [], "O": []},
                lastPlay: {player: "X", tile: 0},
                winningCombos: [
                            [1,2,3],
                            [1,5,9],
                            [1,4,7],
                            [2,5,8],
                            [3,6,9],
                            [3,5,7],
                            [4,5,6],
                            [7,8,9]
                    ]
            };
        },
        initialize: function(){
            //assign inPlay to empty board (give all 9 positions value of empty)
            var temp = {};
            for(var i=1; i <= 9; i++){
                temp["piece" + i.toString()] = '<a href="#/placePiece/' + i.toString() + '" /></a>';
            }
            this.set("inPlay", temp);
        },
        place: function(turn, tile){            
            //set this tile to piece
            var oldInPlay = this.get("inPlay");            
            oldInPlay["piece" + tile.toString()] = '<div class="' + turn.toLowerCase() + '-piece piece"></div>';
            //return complete inPlay object
            this.set("inPlay", oldInPlay);

            //update positions for evaluation
            var oldPositions = this.get("positions");
            var currentTurn = oldPositions[turn];
            currentTurn.push(tile);
            currentTurn.sort();
            oldPositions[turn] = currentTurn;
            this.set("positions", oldPositions);

            var lastPlay = this.get("lastPlay");
            lastPlay["player"] = turn;
            lastPlay["tile"] = tile;
            this.set("lastPlay", lastPlay);

            return this.get("inPlay");
        },
        renderFinished: function(location){
            var positionList = this.get("positions"),
                xList = positionList.X,
                oList = positionList.O,
                filledSpaces = xList.concat(oList).map(function(x){ return parseInt(x);}),
                emptySpaces = _.difference([1,2,3,4,5,6,7,8,9], filledSpaces),
                oldInPlay = this.get("inPlay");

                for(var i = 0; i < emptySpaces.length; i++){
                    oldInPlay["piece" + emptySpaces[i].toString()] = '<div class="piece"></div>';
                }

                var winners = location.split('-');
                for(var i = 0; i < winners.length; i++){
                    oldInPlay["piece" + winners[i]] = oldInPlay["piece" + winners[i]].replace('class="', 'class="active ');
                }

                oldInPlay["complete"] = true;
                
                this.set("inPlay", oldInPlay);
                return this.get("inPlay");
        }

    });

    var Router = Backbone.Router.extend({
        routes: {
            ""      : "home",
            "placePiece/:tile" : "nextPlay",
            "winner/:player/:location" : "endGame",
            "new" : "newGame"
        }
    });

    var router = new Router(),
        board,
        newState,
        newPiece;

    router.on('route:nextPlay', function(tile){
        //place piece then revert to next turn
        board.render(newPiece.place(newState.get("turn"), tile));
        var gameResult = newState.evalGame(newPiece.get("positions"), newPiece.get("winningCombos"), newPiece.get("lastPlay"));
        if(gameResult !== false)
            router.navigate("winner/" + gameResult.winner + "/" + gameResult.sequence, {trigger: true});
        else
            newState.nextTurn();
    });

    router.on('route:endGame', function(player, location){
        //modify styles to lower opacity on everything but winning move
        board.render(newPiece.renderFinished(location));
    });

    router.on('route:newGame', function(){
        //reset GameBoard but keep score
        board = new tttGameBoard();
        newState = new tttGameState();
        newPiece = new tttGamePiece();

        board.render(newPiece.get("inPlay"));
    })

    Backbone.history.start();
</script>
</body>
</html>