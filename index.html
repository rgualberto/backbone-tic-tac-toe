<html>
<head>
    <link rel="stylesheet" href="styles/style.css" />
</head>
<body>

    <div class="page">

    </div>

<script type="text/template" id="ttt-board-template">

<table id="play-table" class="ttt-board <%= done %>">
    <tr>
        <% var j = 0; %>
        <% _.each(pieces, function(piece){ %>
            <% if(j == 3 || j == 6){ %>
                </tr><tr>
            <% } %>
            <% j++ %>
            <td><%= piece %></td>
        <% }); %>
    </tr>
</table>

</script>

<script src="scripts/jquery.min.js"></script>
<script src="scripts/underscore-min.js"></script>
<script src="scripts/backbone.js"></script>
<script>
    var tttBoard = Backbone.View.extend({
        el: ".page",
        render: function(pieces) {
            //render board
            var done = (pieces["complete"] != undefined && pieces["complete"] == true)?"complete":"";
            if(done)
                delete pieces["complete"];
            var boardTemplate = _.template($('#ttt-board-template').html(), {"pieces": pieces, "done": done});
            this.$el.html(boardTemplate);
        }
    });

    var tttState = Backbone.Model.extend({
        defaults: function(){
            return {
                turn: "X"
            };
        },
        nextTurn: function(){
            //switch to opposite state on call
            if (this.get('turn') == "X")
                this.set("turn", "O");
            else
                this.set("turn", "X");
        },
        evalGame: function(positions, winningCombos){
            //return boolean false if not over, else return winner character (eg. "X");
            var inProgress = true;

            var turns = ["X", "O"];
            for(var i = 0; i < 2; i++){
                //don't run if min moves to win hasn't been reached
                if(positions[turns[i]].length < 3) continue;
                var l1 = winningCombos[positions[turns[i]][0]];
                if(l1 != undefined && l1.length != 0){ //Check
                    for(var j = 0;j < l1.length; j++){
                        l2 = l1[j];
                        if(l2 != undefined && l2.length != 0){ //Check
                            for(var k = 0;k < l2.length; k++){
                                if(positions[turns[i]].indexOf(l2[k].toString()) == -1){
                                    inProgress = false;
                                    break;
                                }
                            }
                            if(inProgress)
                                return {"winner": turns[i], "sequence": l2.join('-')};
                            else
                                inProgress = true;
                        }
                    }
                }
            }
            return false;
        }

    });

    var tttPiece = Backbone.Model.extend({
        defaults: function(){
            return {
                inPlay: {},
                positions: {"X": [], "O": []},
                winningCombos: [
                        [],
                        [
                            [1,2,3],
                            [1,5,9],
                            [1,4,7]
                        ],
                        [
                            [2,5,8],
                        ],
                        [
                            [3,6,9],
                            [3,5,7],
                        ],
                        [
                            [4,5,6]
                        ],
                        [],[],
                        [
                            [7,8,9]
                        ]
                    ]
            };
        },
        initialize: function(){
            //assign inPlay to empty board (give all 9 positions value of empty)
            var temp = {};
            for(var i=1; i <= 9; i++){
                temp["piece" + i.toString()] = '<a href="#/placePiece/' + i.toString() + '" /></a>';
            }
            this.set("inPlay", temp);
        },
        place: function(turn, tile){            
            //set this tile to piece
            var oldInPlay = this.get("inPlay");            
            oldInPlay["piece" + tile.toString()] = '<div class="' + turn.toLowerCase() + '-piece piece"></div>';
            //return complete inPlay object
            this.set("inPlay", oldInPlay);

            //update positions for evaluation
            var oldPositions = this.get("positions");
            var currentTurn = oldPositions[turn];
            currentTurn.push(tile);
            currentTurn.sort();
            oldPositions[turn] = currentTurn;
            this.set("positions", oldPositions);

            return this.get("inPlay");
        },
        renderFinished: function(location){
            var positionList = this.get("positions"),
                xList = positionList.X,
                oList = positionList.O,
                filledSpaces = xList.concat(oList).map(function(x){ return parseInt(x);}),
                emptySpaces = _.difference([1,2,3,4,5,6,7,8,9], filledSpaces),
                oldInPlay = this.get("inPlay");

                for(var i = 0; i < emptySpaces.length; i++){
                    oldInPlay["piece" + emptySpaces[i].toString()] = '<div class="piece"></div>';
                }

                var winners = location.split('-');
                for(var i = 0; i < winners.length; i++){
                    oldInPlay["piece" + winners[i]] = oldInPlay["piece" + winners[i]].replace('class="', 'class="active ');
                }

                oldInPlay["complete"] = true;
                
                this.set("inPlay", oldInPlay);
                return this.get("inPlay");
        }

    });

    var Router = Backbone.Router.extend({
        routes: {
            ""      : "home",
            "placePiece/:tile" : "nextPlay",
            "winner/:player/:location" : "endGame"
        }
    });

    var newState = new tttState();
    var router = new Router();
    var board = new tttBoard();
    var newPiece = new tttPiece();

    router.on('route:endGame', function(player, location){
        //modify styles to lower opacity on everything but winning move
        board.render(newPiece.renderFinished(location));
    });

    router.on('route:home', function(){
        //render board - reset timer to 0
        board.render(newPiece.get("inPlay"));
    });

    router.on('route:nextPlay', function(tile){
        //place piece then revert to next turn
        board.render(newPiece.place(newState.get("turn"), tile));
        var gameResult = newState.evalGame(newPiece.get("positions"), newPiece.get("winningCombos"));
        if(gameResult !== false)
            router.navigate("winner/" + gameResult.winner + "/" + gameResult.sequence, {trigger: true});
        else
            newState.nextTurn();
    });

    Backbone.history.start();
</script>
</body>
</html>